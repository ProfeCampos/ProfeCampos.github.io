<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tomo 13: Proyecto 3 - Manual de Instrumentaci칩n</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="tomo-style.css">

   
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/arduino-light.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

</head>
<body>
    <header>
        <div class="header-container">
            <h1>Tomo 13: Estaci칩n Ambiental y Radar Gr치fico</h1>
        </div>
    </header>
    <main class="tomo-content">
            <div class="nav-links">
            <a href="index.html" class="nav-link">&larr; Volver al 칈ndice</a>
            <span>춰Misi칩n Final!</span> </div>        
        <p>춰Ha llegado la hora, equipo! La misi칩n final del curso. Este no es solo un proyecto, es la s칤ntesis de todas sus habilidades. Van a construir un dispositivo de instrumentaci칩n completo, multifuncional e interactivo que integra medici칩n ambiental, detecci칩n de proximidad, registro de datos y una interfaz gr치fica avanzada. Hoy se convierten en dise침adores de sistemas embebidos.</p>
        
        <div class="protagonista-section">
            <h3>游 La Misi칩n Final: Integraci칩n Total</h3>
            <p>Construiremos una estaci칩n "todo en uno" que mide temperatura y distancia, permite navegar entre <strong>cuatro pantallas</strong> con un Joystick, activa <strong>alertas sonoras</strong> con un Buzzer, permite <strong>resetear datos</strong> con el bot칩n del joystick y muestra un impresionante <strong>radar gr치fico</strong> con barrido y detecci칩n de objetos.</p>
        </div>

        <h2>游 El C칩digo: El Sistema Operativo Final</h2>
        <p>Este es el c칩digo m치s completo del curso. Gestiona 4 pantallas, m칰ltiples sensores, actuadores y entradas de usuario simult치neamente.</p>
        <div class="code-container">
            <div class="code-header">
                <span>C칩digo Arduino</span>
                <button class="copy-btn">Copiar</button>
            </div>
            
                <pre><code class="language-cpp code-block">
/*
 * PROYECTO INTEGRADOR 3 (Definitivo): Estaci칩n Ambiental y Radar Gr치fico
 * Descripci칩n: Mide temp/distancia, muestra en 4 pantallas OLED navegables,
 * registra datos, controla servo y tiene alertas sonoras.
 * Por: Profe Campos
 * CECyTEM 05 Guacamayas
*/

// --- INCLUSI칍N DE LIBRER칈AS (NUESTRAS "CAJAS DE HERRAMIENTAS") ---
#include <Wire.h>                // Necesaria para la comunicaci칩n I2C (la usan la pantalla y el sensor de presi칩n).
#include <Adafruit_GFX.h>        // Librer칤a gr치fica base de Adafruit. Nos da las funciones para dibujar formas (l칤neas, c칤rculos, etc.).
#include <Adafruit_SSD1306.h>    // Librer칤a espec칤fica para controlar nuestra pantalla OLED.
#include <OneWire.h>             // Librer칤a para el protocolo de comunicaci칩n de 1 solo cable del sensor de temperatura.
#include <DallasTemperature.h>   // Librer칤a que simplifica la lectura del sensor DS18B20.
#include <Servo.h>               // Librer칤a para controlar f치cilmente el servomotor.

// --- OBJETOS Y PINES (DEFINIENDO NUESTRO HARDWARE) ---
// Creamos un "objeto" para la pantalla, le damos sus dimensiones y le decimos que use I2C.
Adafruit_SSD1306 display(128, 64, &Wire, -1); 
// Creamos los objetos para el protocolo One-Wire y el sensor de temperatura en el pin 2.
OneWire oneWire(2);
DallasTemperature sensors(&oneWire);
// Creamos un objeto para nuestro servomotor.
Servo miServo;

// Definimos constantes para los pines. Es una excelente pr치ctica de programaci칩n
// para hacer el c칩digo m치s legible y f치cil de modificar en el futuro.
const int pinTrig = 9;
const int pinEcho = 10;
const int pinJoyY = A0;
const int pinJoySW = 3;   // Pin para el bot칩n del Joystick.
const int pinServo = 6;
const int pinBuzzer = 4;

// --- VARIABLES GLOBALES (LA MEMORIA DE NUESTRO PROGRAMA) ---
// Esta variable es el "cerebro" de nuestro men칰. Guarda en qu칠 pantalla estamos.
int pantallaActual = 0; // 0=Principal, 1=DataLog, 2=Radar Gr치fico, 3=Radar Num칠rico

// Variables para almacenar las lecturas de los sensores.
float distanciaCm = 0;
float tempC = 0;
long duracion; // Necesita ser 'long' para guardar valores grandes de microsegundos.

// Variables para el registro de datos (Data Logging).
// Las inicializamos con valores "imposibles" para que la primera lectura real los reemplace.
float tempMax = -100; // Un valor muy bajo para asegurar que la primera lectura sea mayor.
float tempMin = 200;  // Un valor muy alto para asegurar que la primera lectura sea menor.
float distMax = 0;
float distMin = 500; // Un valor alto para asegurar que la primera lectura sea menor.

//=============================================================================
// FUNCI칍N SETUP: Se ejecuta UNA SOLA VEZ al encender o resetear el Arduino.
//=============================================================================
void setup() {
  // Iniciamos la comunicaci칩n con la computadora para poder ver mensajes de depuraci칩n.
  Serial.begin(9600);
  
  // Iniciamos cada componente de hardware.
  sensors.begin(); // Inicia la comunicaci칩n con el sensor de temperatura.
  miServo.attach(pinServo); // Asocia nuestro objeto servo al pin f칤sico 6.
  
  // Configuramos los pines (INPUT o OUTPUT).
  pinMode(pinTrig, OUTPUT);
  pinMode(pinEcho, INPUT);
  pinMode(pinBuzzer, OUTPUT);
  // Configuramos el pin del bot칩n del joystick como entrada con una resistencia PULL-UP interna.
  // Esto significa que el pin estar치 en HIGH por defecto, y en LOW cuando se presione (lo conecta a GND).
  pinMode(pinJoySW, INPUT_PULLUP); 
  
  // Intentamos iniciar la pantalla OLED y mostramos un error si no se encuentra.
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("Fallo al iniciar SSD1306"));
    for(;;); // Detiene el programa si no hay pantalla.
  }
  
  // Mostramos una pantalla de bienvenida.
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(10, 10);
  display.println("SISTEMA");
  display.setCursor(10, 35);
  display.println("INICIADO");
  display.display(); // 춰Crucial! Este comando dibuja todo lo preparado en la pantalla.
  delay(2000);
}

//=============================================================================
// FUNCI칍N LOOP: El coraz칩n del programa. Se repite infinitamente.
//=============================================================================
void loop() {
  // --- NAVEGACI칍N Y ACCIONES DEL JOYSTICK ---
  // Leemos el valor anal칩gico del eje Y del joystick (0-1023).
  int valorJoy = analogRead(pinJoyY);
  if (valorJoy < 100) { // Si el joystick se mueve hacia abajo...
    pantallaActual++; // ...pasamos a la siguiente pantalla.
    if (pantallaActual > 3) pantallaActual = 0; // Si nos pasamos de la 3, volvemos a la 0.
    delay(200); // Peque침a pausa para evitar que un solo toque cambie varias pantallas.
  }
  if (valorJoy > 900) { // Si el joystick se mueve hacia arriba...
    pantallaActual--; // ...vamos a la pantalla anterior.
    if (pantallaActual < 0) pantallaActual = 3; // Si nos pasamos de la 0, vamos a la 3.
    delay(200);
  }
  // Si estamos en la pantalla de Data Log (1) y el bot칩n se presiona (estado LOW)...
  if (pantallaActual == 1 && digitalRead(pinJoySW) == LOW) {
    resetDataLog(); // ...llamamos a la funci칩n para reiniciar los datos.
  }

  // --- LECTURA DE SENSORES ---
  leerSensores(); // Llamamos a una funci칩n para mantener el loop limpio y ordenado.

  // --- ACTUALIZACI칍N DE DATOS M츼XIMOS Y M칈NIMOS ---
  actualizarDataLog(); // Llamamos a la funci칩n que compara y actualiza los registros.

  // --- COMPROBACI칍N DE ALERTAS (SIEMPRE ACTIVA) ---
  comprobarAlertas(); // Esta funci칩n revisa si hay condiciones de peligro en cada ciclo.

  // --- ACTUALIZAR PANTALLA ---
  display.clearDisplay(); // Limpiamos el buffer de la pantalla antes de dibujar de nuevo.
  
  // Decidimos qu칠 pantalla dibujar bas치ndonos en la variable 'pantallaActual'.
  if (pantallaActual == 0) dibujarPantallaPrincipal();
  else if (pantallaActual == 1) dibujarPantallaDataLog();
  else if (pantallaActual == 2) dibujarPantallaRadarGrafico();
  else if (pantallaActual == 3) dibujarPantallaRadarNumerico();
  
  display.display(); // Mostramos en la pantalla f칤sica todo lo que dibujamos.
  delay(100); // Pausa general para dar estabilidad al ciclo.
}

//=============================================================================
// --- FUNCIONES AUXILIARES ---
// Dividir el c칩digo en funciones m치s peque침as lo hace m치s legible y reutilizable.
//=============================================================================

// Funci칩n para leer todos los sensores y actualizar sus variables.
void leerSensores() {
  sensors.requestTemperatures(); 
  tempC = sensors.getTempCByIndex(0);
  
  digitalWrite(pinTrig, LOW);
  delayMicroseconds(2);
  digitalWrite(pinTrig, HIGH);
  delayMicroseconds(10);
  digitalWrite(pinTrig, LOW);
  duracion = pulseIn(pinEcho, HIGH);
  distanciaCm = duracion * 0.0343 / 2.0;
  distanciaCm = constrain(distanciaCm, 0, 200); // Limitamos la lectura a un m치ximo de 200cm para evitar valores err칩neos.
}

// Funci칩n para comparar las lecturas actuales con los m치ximos/m칤nimos guardados.
void actualizarDataLog() {
  if (tempC > tempMax) tempMax = tempC;
  if (tempC < tempMin) tempMin = tempC;
  if (distanciaCm > distMax) distMax = distanciaCm;
  // Solo actualizamos el m칤nimo si la distancia es mayor a 0 para ignorar lecturas fallidas.
  if (distanciaCm < distMin && distanciaCm > 0) distMin = distanciaCm; 
}

// Funci칩n para reiniciar los datos del Data Logger.
void resetDataLog() {
  tempMax = tempC; // Reinicia al valor actual.
  tempMin = tempC; // Reinicia al valor actual.
  distMax = distanciaCm;
  distMin = distanciaCm;
  
  // Damos una retroalimentaci칩n al usuario para que sepa que la acci칩n se realiz칩.
  tone(pinBuzzer, 1500, 100); // Un "bip" agudo y corto.
  display.clearDisplay();
  display.setTextSize(2);
  display.setCursor(15,25);
  display.print("DATOS");
  display.setCursor(5,45);
  display.print("REINICIADOS");
  display.display();
  delay(1000); // Mostramos el mensaje por 1 segundo.
}

// Funci칩n que revisa las condiciones de peligro en cada ciclo del loop.
void comprobarAlertas() {
  // La condici칩n es: si la temperatura supera 40 grados O (||) la distancia es menor a 10cm (y no es 0).
  if (tempC > 40.0 || (distanciaCm < 10 && distanciaCm > 0)) {
    // Indicador visual: un tri치ngulo parpadeante en la esquina superior izquierda.
    display.fillTriangle(0,0, 10,0, 0,10, SSD1306_WHITE);
    // Alerta sonora: un tono de 2000 Hz por 150 milisegundos.
    tone(pinBuzzer, 2000, 150);
  }
}

// --- FUNCIONES DE DIBUJO DE PANTALLAS ---

// Dibuja la pantalla principal (Temperatura).
void dibujarPantallaPrincipal() {
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.print("--- MONitoreo AMBIENTAL ---");
  display.setTextSize(2);
  display.setCursor(5, 20);
  display.print(tempC, 1);
  display.print(" ");
  display.setTextSize(1);
  display.drawCircle(75, 22, 3, SSD1306_WHITE); // S칤mbolo de grados.
  display.setTextSize(2);
  display.print("C");
  // El servo act칰a como una aguja, mapeando un rango de temperatura (0-50춿C) al rango del servo (0-180춿).
  int anguloTemp = map(tempC, 0, 50, 0, 180);
  miServo.write(anguloTemp);
  display.setTextSize(1);
  display.setCursor(0, 55);
  display.print("Mover Joystick para ver mas");
}

// Dibuja la pantalla de registro de datos.
void dibujarPantallaDataLog() {
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.print("--- REGISTRO DE DATOS ---");
  display.setCursor(0, 15);
  display.print("T.Max: "); display.print(tempMax, 1); display.print("C");
  display.setCursor(0, 28);
  display.print("T.Min: "); display.print(tempMin, 1); display.print("C");
  display.setCursor(0, 41);
  display.print("D.Max: "); display.print(distMax, 0); display.print("cm");
  display.setCursor(0, 54);
  display.print("D.Min: "); display.print(distMin, 0); display.print("cm");
}

// Dibuja la pantalla del radar gr치fico.
void dibujarPantallaRadarGrafico() {
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.print("--- RADAR GRAFICO ---");
  
  // Esta l칩gica crea un barrido continuo del servo de 0 a 180 y de regreso.
  static int anguloScan = 0; // 'static' hace que la variable recuerde su valor entre llamadas a la funci칩n.
  static int direccion = 1; // 1 para adelante, -1 para atr치s.
  anguloScan += direccion;
  if (anguloScan >= 180 || anguloScan <= 0) {
    direccion *= -1; // Invierte la direcci칩n al llegar a los extremos.
  }
  miServo.write(anguloScan);

  // Dibujar el arco del radar usando una funci칩n de la librer칤a GFX.
  display.drawArc(64, 63, 60, 60, 0, 180, SSD1306_WHITE);

  // Dibujar la l칤nea de barrido. Requiere algo de trigonometr칤a (seno y coseno) para
  // calcular el punto final (x2, y2) de la l칤nea bas치ndose en el 치ngulo del servo.
  float anguloRad = anguloScan * PI / 180.0; // Convertimos el 치ngulo a radianes.
  int x2 = 64 - cos(anguloRad) * 60;
  int y2 = 63 - sin(anguloRad) * 60;
  display.drawLine(64, 63, x2, y2, SSD1306_WHITE);

  // Si detectamos un objeto dentro del rango del radar (60cm)...
  if (distanciaCm < 60) {
    // ...calculamos su posici칩n en la pantalla bas치ndonos en el 치ngulo actual del servo y la distancia medida.
    float anguloBlip = miServo.read() * PI / 180.0;
    int xBlip = 64 - cos(anguloBlip) * distanciaCm;
    int yBlip = 63 - sin(anguloBlip) * distanciaCm;
    display.fillCircle(xBlip, yBlip, 3, SSD1306_WHITE); // Dibujamos el "blip" del objeto.
  }
}

// Dibuja la pantalla del radar num칠rico.
void dibujarPantallaRadarNumerico() {
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.print("--- RADAR DE PROXIMIDAD ---");
  display.setTextSize(3);
  display.setCursor(5, 25);
  display.print(distanciaCm, 0);
  display.setTextSize(2);
  display.print("cm");
  // La barra se llena a medida que el objeto se acerca (mapeo inverso de distancia).
  int barra = map(distanciaCm, 100, 5, 0, 128);
  barra = constrain(barra, 0, 128);
  display.fillRect(0, 58, barra, 6, SSD1306_WHITE);
  // El servo act칰a como un indicador de aguja, tambi칠n inverso a la distancia.
  int anguloDist = map(distanciaCm, 5, 100, 180, 0);
  miServo.write(anguloDist);
}
            </code></pre>
        </div>

        <h2>游댋 Manos a la Obra: El Circuito</h2>
        <p>Este es el circuito final. Combina todos los componentes que hemos usado en el parcial. La gesti칩n del cableado en la protoboard ser치 parte del reto para lograr un montaje limpio y funcional.</p>
        <div class="image-container">
            <h3>Diagrama del Circuito 13</h3>
            <img src="Tomo 13.png" alt="Diagrama de conexi칩n del proyecto final del tercer parcial">
        </div>

        <h2>游눠 Conceptos Clave de la Misi칩n</h2>
        <ul>
            <li><strong>Multitarea Secuencial:</strong> Aunque el Arduino solo hace una cosa a la vez, al hacerlas muy r치pido en el `loop()` (leer, procesar, dibujar), se crea la ilusi칩n de que todo sucede al mismo tiempo.</li>
            <li><strong>Modularidad del C칩digo:</strong> Dividir un programa complejo en funciones m치s peque침as y espec칤ficas hace que sea m치s f치cil de escribir, depurar y entender.</li>
            <li><strong>Dise침o de Sistemas Embebidos:</strong> El proceso de integrar hardware y software para cumplir un conjunto de requisitos espec칤ficos en un dispositivo aut칩nomo.</li>
        </ul>

        <h2>游 춰Felicidades! 춰Misi칩n Cumplida!</h2>
        <p>Al completar este proyecto, no solo has aprendido a seguir instrucciones, has aprendido a pensar como un ingeniero: a analizar un problema, a dividirlo en partes m치s peque침as, a seleccionar los componentes adecuados y a escribir la l칩gica para que todo funcione en armon칤a. 춰El futuro de la automatizaci칩n est치 en tus manos!</p>
         <div class="nav-links bottom-nav-links">
            <a href="index.html" class="nav-link">&larr; Volver al 칈ndice</a>
            <span>춰Misi칩n Final!</span>
        </div>
    </main>
    <footer>
        <p>Manual Digital de Instrumentaci칩n Industrial | CECyTEM 05 Guacamayas</p>
    </footer>
    
  <script>hljs.highlightAll();</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Busca todos los botones de copiar
    const allCopyButtons = document.querySelectorAll('.copy-btn');
    allCopyButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Encuentra el contenedor de c칩digo m치s cercano
            const codeContainer = this.closest('.code-container');
            // Encuentra el bloque de c칩digo dentro de ese contenedor
            const codeBlock = codeContainer.querySelector('code');
            
            if (codeBlock) {
                // Copia el texto del c칩digo al portapapeles
                navigator.clipboard.writeText(codeBlock.innerText).then(() => {
                    // Feedback visual para el usuario
                    this.innerText = '춰Copiado!';
                    setTimeout(() => {
                        this.innerText = 'Copiar';
                    }, 2000); // Vuelve al texto original despu칠s de 2 segundos
                }).catch(err => {
                    console.error('Error al copiar el c칩digo: ', err);
                });
            }
        });
    });
});
</script>

</body>

</html>






