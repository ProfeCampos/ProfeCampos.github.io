<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tomo 12: Term칩metro Multiescala - Manual de Instrumentaci칩n</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="tomo-style.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/arduino-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

</head>
<body>
    <header>
        <div class="header-container">
            <h1>Tomo 12: Term칩metro Multiescala con Interfaz Gr치fica</h1>
        </div>
    </header>
    <main class="tomo-content">
 <div class="nav-links">
            <a href="index.html" class="nav-link">&larr; Volver al 칈ndice</a>
            <a href="tomo13.html" class="nav-link">Tomo Siguiente &rarr;</a>
        </div>
        <p>Hoy vamos a subir de nivel en la precisi칩n de nuestras mediciones y en la calidad de nuestra interfaz visual. Crearemos un term칩metro de alta precisi칩n con el sensor <strong>DS18B20</strong>, mostraremos los datos en una n칤tida <strong>pantalla OLED</strong> y usaremos un <strong>Joystick</strong> para navegar entre m칰ltiples pantallas, como si fuera un dispositivo profesional.</p>

        <div class="protagonista-section">
            <h3>游 Protagonistas de la Misi칩n</h3>
            <p><strong>DS18B20:</strong> Un term칩metro digital de alta precisi칩n que se comunica por el protocolo "One-Wire", permitiendo conectar varios sensores a un solo pin.<br>
            <div class="image-container">
            <img src="ds18b20 piout.png" alt="pinout ds18b20">
            </div>
            <strong>Pantalla OLED:</strong> Una pantalla de alto contraste que no necesita luz de fondo, perfecta para gr치ficos n칤tidos y de bajo consumo.<br>
            <div class="image-container">
            <img src="I2C-OLED-Display-Pinout.png" alt="pinout oled">
            </div>
            <strong>M칩dulo Joystick:</strong> Nuestro dispositivo de entrada, que combina dos potenci칩metros (ejes X/Y) y un bot칩n para navegar por los men칰s.</p>
             <div class="image-container">
            <img src="Pinout-PS2-Joystick-Module.png" alt="pinout oled">
            </div>        
        </div>

        <h2>游 El C칩digo: El Sistema Operativo del Term칩metro</h2>
        <p>Este c칩digo avanzado usa una variable para saber qu칠 men칰 mostrar (`pantallaActual`). El joystick cambia el valor de esta variable, y una estructura `if/else if` en el `loop` se encarga de dibujar la pantalla correcta.</p>
        
 <div class="code-container"> 
    <div class="code-header">
        <span>C칩digo Arduino</span>
        <button class="copy-btn">Copiar</button>
    </div> 
<pre><code class="language-cpp code-block">       
 /*
 * Misi칩n 12 (Modificada): Term칩metro Multiescala con UI
 * Por: Profe Campos
 * CECyTEM 05 Guacamayas
*/

#include &lt;OneWire.h&gt;
#include &lt;DallasTemperature.h&gt;
#include &lt;Wire.h&gt;
#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_SSD1306.h&gt;

// --- CONFIGURACI칍N DE PANTALLA ---
// Definimos constantes para el tama침o de nuestra pantalla. Es una buena pr치ctica
// para no tener "n칰meros m치gicos" esparcidos por el c칩digo.
#define SCREEN_WIDTH 128 // Ancho de la pantalla OLED en p칤xeles.
#define SCREEN_HEIGHT 64 // Alto de la pantalla OLED en p칤xeles.

// Creamos un "objeto" para nuestra pantalla. Piensa en esto como darle un nombre
// y asignarle sus caracter칤sticas para poder darle 칩rdenes despu칠s.
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// --- CONFIGURACI칍N DEL SENSOR ---
#define ONE_WIRE_BUS 2 // Le decimos al programa que nuestro sensor DS18B20 est치 en el Pin Digital 2.

// Creamos los objetos necesarios para manejar la comunicaci칩n One-Wire y el sensor.
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);

// --- CONFIGURACI칍N DEL JOYSTICK ---
const int pinJoyY = A0; // Le decimos al programa que leeremos el eje Y del joystick en el Pin Anal칩gico 0.

// --- VARIABLES GLOBALES ---
// Estas variables son "globales" porque se pueden usar en cualquier parte del programa.

// Esta es la variable M츼S IMPORTANTE para el men칰. Act칰a como un "marcador de p치gina".
// Nos dice en qu칠 pantalla estamos actualmente. 0=C/R, 1=F/K, 2=Gr치ficos.
int pantallaActual = 0; 

// Variables para almacenar las temperaturas en las diferentes escalas.
// Usamos el tipo "float" porque las temperaturas pueden tener decimales.
float tempC = 0.0; // Grados Celsius
float tempF = 0.0; // Grados Fahrenheit
float tempK = 0.0; // Grados Kelvin
float tempR = 0.0; // Grados Rankine

// La funci칩n setup() se ejecuta UNA SOLA VEZ al inicio del programa.
void setup() {
  // Iniciamos la comunicaci칩n con el Monitor Serial de la computadora. Es 칰til para depurar.
  Serial.begin(9600);
  
  // Iniciamos el sensor de temperatura.
  sensors.begin();

  // Intentamos iniciar la pantalla OLED.
  // Si la funci칩n 'begin' devuelve 'false' (falso), significa que no encontr칩 la pantalla.
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { 
    Serial.println(F("Fallo al iniciar SSD1306")); // Mandamos un mensaje de error al monitor serial.
    for(;;); // Creamos un bucle infinito para detener el programa si la pantalla no funciona.
  }
  
  // Mostramos un mensaje de bienvenida en la pantalla OLED.
  display.clearDisplay();       // Primero, nos aseguramos de que la pantalla est칠 limpia.
  display.println("Iniciando..."); // Escribimos el texto.
  display.display();            // 춰Muy importante! Este comando "dibuja" en la pantalla f칤sica lo que preparamos.
  delay(1000);                  // Esperamos un segundo para que se pueda leer.
}

// La funci칩n loop() se repite infinitamente mientras el Arduino tenga energ칤a.
void loop() {
  // --- PASO 1: LEER TEMPERATURA Y HACER LAS CONVERSIONES ---
  // Le pedimos a todos los sensores en el bus One-Wire que midan la temperatura.
  sensors.requestTemperatures(); 
  
  // Obtenemos la temperatura en Celsius del primer sensor que encuentre (칤ndice 0).
  tempC = sensors.getTempCByIndex(0);
  
  // Calculamos las otras escalas a partir de los grados Celsius.
  tempF = tempC * 9.0 / 5.0 + 32.0;       // F칩rmula de conversi칩n a Fahrenheit.
  tempK = tempC + 273.15;                 // F칩rmula de conversi칩n a Kelvin.
  tempR = (tempC + 273.15) * 9.0 / 5.0;   // F칩rmula de conversi칩n a Rankine.

  // --- PASO 2: LEER EL JOYSTICK PARA NAVEGAR ENTRE PANTALLAS ---
  // Leemos el valor anal칩gico del eje Y del joystick. Ser치 un n칰mero entre 0 y 1023.
  int valorJoy = analogRead(pinJoyY);
  
  // Si el valor es muy bajo (joystick movido hacia abajo)...
  if (valorJoy < 100) {
    pantallaActual++; // ...incrementamos nuestro "marcador de p치gina".
    // Si nos pasamos de la 칰ltima p치gina (2), volvemos a la primera (0).
    if (pantallaActual > 2) pantallaActual = 0;
    delay(200); // Peque침o delay para evitar que cambie de pantalla m칰ltiples veces con un solo toque.
  }
  
  // Si el valor es muy alto (joystick movido hacia arriba)...
  if (valorJoy > 900) {
    pantallaActual--; // ...decrementamos nuestro "marcador de p치gina".
    // Si nos pasamos de la primera p치gina (0), vamos a la 칰ltima (2).
    if (pantallaActual < 0) pantallaActual = 2;
    delay(200); // Peque침o delay para evitar saltos m칰ltiples.
  }

  // --- PASO 3: DIBUJAR LA PANTALLA CORRESPONDIENTE ---
  display.clearDisplay();            // Limpiamos lo que hab칤a antes en la pantalla.
  display.setTextColor(SSD1306_WHITE); // Fijamos el color del texto a blanco.

  // Usando 'if / else if', decidimos qu칠 funci칩n de dibujo llamar
  // bas치ndonos en el valor de nuestro "marcador de p치gina".
  if (pantallaActual == 0) {
    dibujarPantallaCR();
  } else if (pantallaActual == 1) {
    dibujarPantallaFK();
  } else if (pantallaActual == 2) {
    dibujarPantallaGrafica();
  }

  // Finalmente, despu칠s de preparar todo, actualizamos la pantalla f칤sica.
  display.display();
  delay(100); // Peque침a pausa general antes de empezar el loop de nuevo.
}

// --- FUNCIONES AUXILIARES DE DIBUJO ---
// Dividir el c칩digo en funciones hace que sea mucho m치s organizado y f치cil de leer.

// Funci칩n para dibujar la primera pantalla (Celsius y Rankine).
void dibujarPantallaCR() {
  // Dibuja un 칤cono simple que cambia con la temperatura.
  if (tempC >= 25) { // Si hace calor...
    display.fillCircle(110, 15, 10, SSD1306_WHITE); // ...dibuja un sol.
  } else { // Si hace fr칤o...
    display.setTextSize(2); display.setCursor(105, 10); display.print("*"); // ...dibuja un copo de nieve.
  }
  
  // Dibuja la temperatura en Celsius.
  display.setTextSize(2);      // Letra de tama침o mediano.
  display.setCursor(5, 10);    // Posiciona el cursor en la columna 5, fila 10.
  display.print(tempC, 1);     // Imprime la variable tempC con 1 decimal.
  display.print(" C");

  // Dibuja la temperatura en Rankine.
  display.setTextSize(2);
  display.setCursor(5, 40);
  display.print(tempR, 1);
  display.print(" R");
}

// Funci칩n para dibujar la segunda pantalla (Fahrenheit y Kelvin).
void dibujarPantallaFK() {
  // Dibuja un 칤cono de term칩metro usando formas b치sicas.
  display.drawRect(105, 10, 15, 45, SSD1306_WHITE); // El cuerpo del term칩metro.
  display.fillCircle(112, 55, 7, SSD1306_WHITE);    // El bulbo del term칩metro.
  
  // Dibuja la temperatura en Fahrenheit.
  display.setTextSize(2);
  display.setCursor(5, 10);
  display.print(tempF, 1);
  display.print(" F");

  // Dibuja la temperatura en Kelvin.
  display.setTextSize(2);
  display.setCursor(5, 40);
  display.print(tempK, 1);
  display.print(" K");
}

// Funci칩n para dibujar la tercera pantalla (los 4 term칩metros gr치ficos).
void dibujarPantallaGrafica() {
  // Dibuja el encabezado de la tabla.
  display.setTextSize(1);
  display.setCursor(0,0);
  display.println("  C    F    K    R");
  display.drawLine(0, 10, 127, 10, SSD1306_WHITE); // L칤nea divisoria.

  // Llama a nuestra funci칩n 'dibujarTermometro' para cada escala de temperatura.
  // Le pasamos la posici칩n X donde queremos dibujarlo, el valor a mostrar, y los
  // valores m칤nimo y m치ximo de esa escala para la barra gr치fica.
  dibujarTermometro(10, tempC, -10, 50);    // Rango para Celsius: de -10 a 50
  dibujarTermometro(40, tempF, 14, 122);    // Rango para Fahrenheit (equivalente a -10/50 C)
  dibujarTermometro(70, tempK, 263, 323);   // Rango para Kelvin (equivalente a -10/50 C)
  dibujarTermometro(100, tempR, 473, 581);  // Rango para Rankine (equivalente a -10/50 C)
}

// Funci칩n s칰per 칰til para dibujar una barra de term칩metro en una posici칩n X.
void dibujarTermometro(int x, float valor, float minVal, float maxVal) {
  int altoBarra = 50; // La altura m치xima en p칤xeles que tendr치 nuestro term칩metro.
  
  // Aqu칤 ocurre la magia: usamos map() para convertir el rango de temperatura
  // (ej. -10 a 50) al rango de p칤xeles (0 a 50).
  int llenado = map(valor, minVal, maxVal, 0, altoBarra);
  
  // La funci칩n constrain() es un seguro. Se asegura de que el valor de 'llenado'
  // nunca sea menor que 0 ni mayor que la altura de la barra.
  llenado = constrain(llenado, 0, altoBarra);
  
  // Dibuja el contorno exterior del term칩metro.
  display.drawRect(x, 12, 15, altoBarra + 2, SSD1306_WHITE);
  
  // Dibuja el relleno. La l칩gica de la posici칩n 'y' es un poco tricky:
  // (13 + (altoBarra - llenado)) hace que el rect치ngulo se "llene" desde abajo hacia arriba.
  display.fillRect(x+1, 13 + (altoBarra - llenado), 13, llenado, SSD1306_WHITE);
}
        </code></pre>
        </div>
        <h2>游댋 Manos a la Obra: El Circuito</h2>
        <p>Este circuito integra los tres m칩dulos principales. La conexi칩n m치s importante es la resistencia de <strong>4.7k풜</strong>, que es obligatoria para que el protocolo One-Wire del sensor DS18B20 funcione correctamente.</p>
        <div class="image-container">
            <h3>Diagrama del Circuito 12</h3>
            <img src="Tomo 12.png" alt="Diagrama de conexi칩n de un sensor DS18B20, una pantalla OLED y un joystick">
        </div>

        <h2>游눠 Conceptos Clave de la Misi칩n</h2>
        <ul>
            <li><strong>Protocolo One-Wire:</strong> Un bus de comunicaci칩n que permite que m칰ltiples dispositivos se comuniquen con el microcontrolador a trav칠s de un solo cable de datos.</li>
            <li><strong>Interfaz de Usuario (UI):</strong> Dise침ar c칩mo el usuario interact칰a con el dispositivo, lo que es clave para que un proyecto sea 칰til y f치cil de usar.</li>
            <li><strong>M치quina de Estados:</strong> Un modelo de programaci칩n donde el sistema se encuentra en uno de varios "estados" (pantallas) y cambia entre ellos basado en las entradas.</li>
        </ul>

        <h2>游 춰Int칠ntalo T칰 Mismo! (Retos)</h2>
        <ul>
            <li><strong>Pantalla de Bienvenida Animada:</strong> Crea una secuencia de inicio animada en la funci칩n `setup()`, por ejemplo, el nombre "CECyTEM 05" apareciendo letra por letra.</li>
            <li><strong>Registrador de Datos:</strong> Programa una cuarta pantalla en el men칰 que muestre las temperaturas m치xima y m칤nima registradas. Usa el bot칩n del joystick para reiniciar estos valores.</li>
            <li><strong>Alarma Visual de Temperatura:</strong> En la pantalla de los term칩metros gr치ficos, haz que si la temperatura supera un umbral (ej. 30춿C), el contorno del term칩metro de Celsius comience a parpadear.</li>
        </ul>
<div class="nav-links bottom-nav-links">
            <a href="index.html" class="nav-link">&larr; Volver al 칈ndice</a>
            <a href="tomo13.html" class="nav-link">Tomo Siguiente &rarr;</a>
        </div>
</main>
    <footer>
        <p>Manual Digital de Instrumentaci칩n Industrial | CECyTEM 05 Guacamayas</p>
    </footer>
<script>hljs.highlightAll();</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Busca todos los botones de copiar
    const allCopyButtons = document.querySelectorAll('.copy-btn');

    allCopyButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Encuentra el contenedor de c칩digo m치s cercano
            const codeContainer = this.closest('.code-container');
            // Encuentra el bloque de c칩digo dentro de ese contenedor
            const codeBlock = codeContainer.querySelector('code');
            
            if (codeBlock) {
                // Copia el texto del c칩digo al portapapeles
                navigator.clipboard.writeText(codeBlock.innerText).then(() => {
                    // Feedback visual para el usuario
                    this.innerText = '춰Copiado!';
                    setTimeout(() => {
                        this.innerText = 'Copiar';
                    }, 2000); // Vuelve al texto original despu칠s de 2 segundos
                }).catch(err => {
                    console.error('Error al copiar el c칩digo: ', err);
                });
            }
        });
    });
});
</script>

</body>

</html>



